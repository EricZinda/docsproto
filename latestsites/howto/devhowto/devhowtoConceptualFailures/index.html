<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>DELPH-IN How-to</title>
<meta name="description" content="An amazing website.">


  <meta name="author" content="Your Name">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="DELPH-IN How-to">
<meta property="og:title" content="DELPH-IN How-to">
<meta property="og:url" content="http://blog.inductorsoftware.com/docsproto/howto/devhowto/devhowtoConceptualFailures/">


  <meta property="og:description" content="An amazing website.">











  

  


<link rel="canonical" href="http://blog.inductorsoftware.com/docsproto/howto/devhowto/devhowtoConceptualFailures/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Your Name",
      "url": "http://blog.inductorsoftware.com/docsproto/howto/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/docsproto/howto/feed.xml" type="application/atom+xml" rel="alternate" title="DELPH-IN How-to Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/docsproto/howto/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--delphin_page wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/docsproto/howto/"><img src="/docsproto/howto/assets/images/Delph-In.png" alt="DELPH-IN How-to"></a>
        
        <a class="site-title" href="/docsproto/howto/">
          DELPH-IN How-to
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/home/Home">Home</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/howto/DelphinWelcome">How-to</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/erg/ErgTop">ERG</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/tools/ToolsTop">Tools</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/grammars/NorsourceTop">Grammars</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/matrix/MatrixTop">Matrix</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/garage/AgreeTop">Garage</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/summits/SummitTop">Summits</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">DELPH-IN</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/DelphinWelcome/">Welcome</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Developer Tutorial</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoOverview/">Overview</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoPredicationContract/">The Predication Contract</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoPyhonBasics/">Python Primer and State</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoImplementPredication/">Implementing a Predication</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoMRSToPython/">MRS To Python</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoConjunctions/">Conjuctions</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoScopalArguments/">Scopal Arguments</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoEvents/">Event Variables</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSentenceForce/">Sentence Force</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSimplePropositions/">Simple Propositions</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSimpleQuestions/">Simple Questions</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSimpleCommands/">Simple Commands</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoChoosingWhichFailure/">Choosing the Right Failure</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoReportingAFailure/">Reporting a Failure</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoConceptualFailures/" class="active">Converting Variables to English</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoPythonDecorators/">A. Python Decorators</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoParsePredication/">B. Parsing Predications</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Grammarian Tutorial</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/DelphinTutorial/">Overview</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Formalisms/">Formalisms</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Grammars/">Grammars</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Processing/">Processing</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Distributions/">Distributions</a></li>
          
            <li><a href="/docsproto/howto/HpsgTutorial/">HPSG</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Other Tutorials</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/ErsTutorial/">English Resource Semantics Tutorial (NAACL 2016)</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <h2 id="converting-variables-to-english">Converting Variables to English</h2>
<p>So far, the code for <code class="language-plaintext highlighter-rouge">large_a_1</code> looks like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, name="_large_a_1")
def large_a_1(state, e_introduced, x_target):
            
    ...
    
            ReportError(f"There is not a large thing")
</code></pre></div></div>

<p>… and will respond to “A file is very large” with “There is not a large thing”. Correct-ish, but not great. We’d <em>really</em> like to report errors at a more conceptual level. The best answer would replace “thing” in “There is not a large thing” with the “type” of thing <code class="language-plaintext highlighter-rouge">x</code> is <em>at the point we are reporting the error</em>. Remember that the <code class="language-plaintext highlighter-rouge">large_a_1</code> predication will be used for anything the user references as “large”, so it will need to be flexible about how it reports its failures.</p>

<p>For example, here is a scope-resolved tree for “A file is large”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          ┌────── _file_n_of(x3,i8)
_a_q(x3,RSTR,BODY)    
               └─ _large_a_1(e2,x3)
</code></pre></div></div>

<p>Errors in that MRS from <code class="language-plaintext highlighter-rouge">_large_a_1</code> should say “There is not a large <em>file</em>” since the only things that can be in <code class="language-plaintext highlighter-rouge">x</code> by the time it gets to <code class="language-plaintext highlighter-rouge">_large_a_1</code> have already been filtered to be files.</p>

<p>For “A dog is large”:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          ┌────── _dog_n_1(x3)
_a_q(x3,RSTR,BODY)    
               └─ _large_a_1(e2,x3)
</code></pre></div></div>
<p>Errors in <em>that</em> MRS from <code class="language-plaintext highlighter-rouge">_large_a_1</code> should say “There is not a large <em>dog</em>”.</p>

<p>etc.</p>

<p>That way, we can write one error message and have it work well no matter how the predication is used.</p>

<h3 id="determining-what-to-call-x">Determining What to Call “x”</h3>
<p>We can figure out what the variable <code class="language-plaintext highlighter-rouge">x</code> has been filtered to “so far” by taking advantage of some things we know:</p>

<ol>
  <li>We know how the tree is executed (depth-first)</li>
  <li>We know what the predications in the tree are</li>
  <li>We know which predication reported the error</li>
  <li>We know where that predication is in the execution order</li>
</ol>

<p>So, if the error came from <code class="language-plaintext highlighter-rouge">_large_a_1</code>, we must have finished <code class="language-plaintext highlighter-rouge">_dog_n_1</code> but be in the middle of resolving <code class="language-plaintext highlighter-rouge">_a_q</code>.  At that point, the variable <code class="language-plaintext highlighter-rouge">x3</code> contains something that is <code class="language-plaintext highlighter-rouge">dog</code> (not even <code class="language-plaintext highlighter-rouge">*a* dog</code> yet).  In this way, we can write code which gives the English description of a variable <em>at a certain point in the tree’s execution</em>. We can use that to build failure messages that have the proper “thing” for any phrase we encounter.</p>

<p>First, let’s create the function (<code class="language-plaintext highlighter-rouge">EnglishForDelphinVariable()</code>) which takes the <code class="language-plaintext highlighter-rouge">variable</code> we want English for, the MRS, and the place in the tree for which we want the English. It walks the tree in execution order using the function we’ve written <a href="../devhowtoSimpleQuestions">in a previous section</a> called <code class="language-plaintext highlighter-rouge">WalkTreeUntil()</code> and passes each predication to a function that determines if they are “filtering” the <code class="language-plaintext highlighter-rouge">variable</code> in question. If so, it adds some data to a structure called <code class="language-plaintext highlighter-rouge">nlg_data</code> (“NLG” stands for “Natural Language Generation”). At the end, we call a function (<code class="language-plaintext highlighter-rouge">ConvertToEnglish</code>) that takes all the gathered data and turns it into English:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Given the index where an error happened and a variable
# return what that variable "is" up to that point, in English
def EnglishForDelphinVariable(failure_index, variable, mrs):
    # Integers can't be passed by reference in Python, so we need to pass
    # the current index in a list so it can be changed as we iterate
    current_predication_index = [0]

    # This function will be called for every predication in the MRS
    # as we walk it in execution order
    def RecordPredicationsUntilFailureIndex(predication):
        # Once we have hit the index where the failure happened, stop
        if current_predication_index[0] == failure_index:
            return False
        else:
            # See if this predication can contribute anything to the
            # description of the variable we are describing. If so,
            # collect it in nlg_data
            RefineNLGWithPredication(variable, predication, nlg_data)
            current_predication_index[0] = current_predication_index[0] + 1
            return None

    nlg_data = {}
    
    # WalkTreeUntil() walks the predications in mrs["RELS"] and calls
    # the function RecordPredicationsUntilFailureIndex(), until hits the
    # failure_index position
    WalkTreeUntil(mrs["RELS"], RecordPredicationsUntilFailureIndex)
    
    # Take the data we gathered and convert to English
    return ConvertToEnglish(nlg_data)
</code></pre></div></div>

<p>For now, <code class="language-plaintext highlighter-rouge">RefineNLGWithPredication()</code> takes a very simple approach to seeing if a predication is “filtering” the <code class="language-plaintext highlighter-rouge">variable</code>. Predications which <em>introduce</em> a variable (as described in a <a href="../devhowtoEvents">previous section</a>) are, in some sense, the base “thing” that the variable is. They should clearly be part of its description. Quantifiers for that variable describe “how much” of it there are, so they should be included as well. There are lots more we could add (and we will later) but keeping it in this simple gets us a long way for now:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># See if this predication in any way contributes words to 
# the variable specified. Put whatever it contributes in nlg_data
def RefineNLGWithPredication(variable, predication, nlg_data):
    # Parse the name of the predication to find out its 
    # part of speech (POS) which could be a noun ("n"), 
    # quantifier ("q"), etc. 
    parsed_predication = ParsePredicationName(predication[0])

    # If the predication has this variable as its first argument,
    # it either *introduces* it, or is quantifying it
    if predication[1] == variable:
        if parsed_predication["Pos"] == "q":
            # It is quantifying it
            nlg_data["Quantifier"] = parsed_predication["Lemma"]
        else:
            # It is introducing it, thus it is the "main" description
            # of the variable, usually a noun predication
            nlg_data["Topic"] = parsed_predication["Lemma"]
</code></pre></div></div>
<p>Finally, we can take the information we gathered and convert it (in a very simple way) to English. Note that generating proper English is <em>much</em> more complicated than this, and we’ll tackle doing it “right” later. For now, our naive approach will illustrate the ideas:</p>

<blockquote>
  <p>Note: The code for parsing the predication is described in an <a href="../devhowtoParsePredication">appendix</a></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Takes the information gathered in the nlg_data dictionary
# and convert it, in a very simplistic way, to English
def ConvertToEnglish(nlg_data):
    if "Quantifier" in nlg_data:
        quantifier = nlg_data["Quantifier"]
    else:
        quantifier = "a"

    if "Topic" in nlg_data:
        topic = nlg_data["Topic"]
    else:
        topic = "thing"

    return f"{quantifier} {topic}"
</code></pre></div></div>
<p>Those functions will provide the start of a system that converts a variable into English, given a spot in the MRS.</p>

<p>One final piece of cleanup work remains. We will be returning a lot of the same errors from different predications, so, instead of littering the code with full sentences like “There is not a large thing”, we’ll use constants like <code class="language-plaintext highlighter-rouge">doesntExist</code> and allow them to take arguments like <code class="language-plaintext highlighter-rouge">x3</code>. Then, using the code above, we can build up the English for them in a shared routine that turns them into English and fills in that English with descriptions of the variables.  Like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># error_term is of the form: [index, error] where "error" is another 
# list like: ["name", arg1, arg2, ...]. The first item is the error 
# constant (i.e. its name). What the args mean depends on the error
def GenerateMessage(mrs, error_term):
    error_predicate_index = error_term[0]
    error_arguments = error_term[1]
    error_constant = error_arguments[0]

    if error_constant == "doesntExist":
        arg1 = EnglishForDelphinVariable(error_constant, error_arguments[1], mrs)
        return f"{arg1} doesn't exist"

    elif error_constant == "adjectiveDoesntApply":
        arg1 = error_arguments[1]
        arg2 = EnglishForDelphinVariable(error_constant, error_arguments[2], mrs)
        return f"{arg2} is not {arg1}"
</code></pre></div></div>
<p>Most of what <code class="language-plaintext highlighter-rouge">GenerateMessage()</code> does is plug the error arguments into a string template.  The interesting work happens when one of the arguments is a Delphin variable and it calls <code class="language-plaintext highlighter-rouge">EnglishForDelphinVariable()</code>.  This is where we solve the problem we started this section with: how to describe what is in that <code class="language-plaintext highlighter-rouge">x</code> variable, as described above.</p>

<p>Finally, we can change our predications to use <code class="language-plaintext highlighter-rouge">ReportError()</code> with the new error format, and change <code class="language-plaintext highlighter-rouge">RespondToMRS()</code> to respond with errors using all the ideas and code we’ve written in the <a href="../devhowtoChoosingWhichFailure">last</a> <a href="../devhowtoReportingAFailure">couple</a> sections:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, name="_file_n_of")
def file_n_of(state, x):
    
    ...

            ReportError(["doesntExist", x])
            
            
@Predication(vocabulary, name="_large_a_1")
def large_a_1(state, e_introduced, x_target):
            
    ...
    
        ReportError(["adjectiveDoesntApply", "large", x_target])
        

def RespondToMRS(self, state, mrs):

    ...
    
    if sentence_force == "prop":
        if len(solutions) &gt; 0:
            print("Yes, that is true.")
        else:
            message = GenerateMessage(mrs, self.Error())
            print(f"No, that isn't correct: {message}")
</code></pre></div></div>
<p>So, the predications like <code class="language-plaintext highlighter-rouge">large_a_1</code> and <code class="language-plaintext highlighter-rouge">file_n_of</code> report their failures as described in the previous sections, but now use a constant and a list of arguments as the “shape” of their errors.  If an MRS can’t be solved, <code class="language-plaintext highlighter-rouge">RespondToMRS()</code> calls the <code class="language-plaintext highlighter-rouge">GenerateMessage()</code> helper function  to turn the error into English and prints it for the user.</p>

<p>With all that in place, we can now take some of our previous examples and make them fail to see what messages we get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Evaluate the proposition: "a file is large" when there are no *large* files
def Example10():
    state = State([Folder(name="Desktop"),
                   Folder(name="Documents"),
                   File(name="file1.txt", size=1000000),
                   File(name="file2.txt", size=1000000)])

    mrs = {}
    mrs["Index"] = "e1"
    mrs["Variables"] = {"x1": {"NUM": "pl"},
                        "e1": {"SF": "prop"}}
    mrs["RELS"] = [["_a_q", "x1", ["_file_n_of", "x1"], ["_large_a_1", "e1", "x1"]]]

    state = state.SetX("mrs", mrs)
    DelphinContext().RespondToMRS(state, mrs)
    
# Prints:
No, that isn't correct: a file is not large
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Evaluate the proposition: "a file is large" when there are no files, period
def Example11():
    state = State([Folder(name="Desktop"),
                   Folder(name="Documents")])

    mrs = {}
    mrs["Index"] = "e1"
    mrs["Variables"] = {"x1": {"NUM": "pl"},
                        "e1": {"SF": "prop"}}
    mrs["RELS"] = [["_a_q", "x1", ["_file_n_of", "x1"], ["_large_a_1", "e1", "x1"]]]

    state = state.SetX("mrs", mrs)
    DelphinContext().RespondToMRS(state, mrs)

# Prints:
No, that isn't correct: a file doesn't exist
</code></pre></div></div>

<p>These can be refined further:</p>
<ul>
  <li>The first example should be more like “no files are large” or “there aren’t any large files”</li>
  <li>The last example should probably be “no files exist” or “there aren’t any files”</li>
</ul>

<p>At this point, though, you have the tools needed to fix those up as much as necessary. The tutorial won’t improve them until we get to a much later section.</p>

<update date="" omitted="" for="" speed="">
</update>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

<!--Scroll the navbar to the current page-->
<script type="text/javascript">
  let el = document.querySelector('.nav__list .active');
  if(el){
    el.scrollIntoView({block: "center", inline: "start"});
  }
</script>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form onsubmit="return googleCustomSearchExecute();" id="cse-search-box-form-id">
    <label class="sr-only" for="cse-search-input-box-id">
      Enter your search term...
    </label>
    <input type="search" id="cse-search-input-box-id" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results">
    <gcse:searchresults-only></gcse:searchresults-only>
  </div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/docsproto/howto/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 Your Name. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/docsproto/howto/assets/js/main.min.js"></script>


<script>
  (function () {
    var cx = '7761c0bff1e224240';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();

  function googleCustomSearchExecute() {
    var input = document.getElementById('cse-search-input-box-id');
    var element = google.search.cse.element.getElement('searchresults-only0');
    if (input.value == '') {
      element.clearAllResults();
    } else {
      element.execute(input.value);
    }
    return false;
  }

  
</script>







  </body>
</html>

{% raw %}# Overview
If you are trying to use natural language as an interface to software, you will need to "evaluate" or "solve" the MRS against the state of the software in order to answer the question being asked or perform the action being requested. This section describes one approach to doing this: iteratively solving the tree of predications in a [scope-resolved tree](). It effectively uses the [depth-first computational SLD approach](https://en.wikipedia.org/wiki/SLD_resolution) that, for example, the Prolog language uses in proving a goal. This approach walks the scope-resolved tree in depth-first order and iteratively finds assignments of variables that make the MRS "true". It uses backtracking to try alternatives when they exist. The approach is relatively straightforward and this section will walk through how to build a solver using Python to make it concrete.  When finished, you will be able to evaluate MRS trees using a surprisingly small amount of Python code.

This tutorial uses the [English Resource Grammar (ERG)](../ErgTop) from DELPH-IN to parse English, but the concepts are the same no matter which DELPH-IN grammar you use. In fact, the Python functions we build have no dependency on the grammar at all and can be used for any of the DELPH-IN grammars.

Python was chosen as a simple, popular, open-source language available on many platforms. However, the examples and approach shown here could be implemented in any language. There is not much code in the core solver and associated helper functions that would need to be translated. The overwhelming majority of code will be in the implementation of the predications you create for your own domain.

Last update: 2022-12-15 by EricZinda [[edit](https://github.com/ericzinda/docsproto/edit/main/devhowto/devhowtoOverview.md)]{% endraw %}
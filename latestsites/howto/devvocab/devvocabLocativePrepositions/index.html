<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>DELPH-IN How-To</title>
<meta name="description" content="An amazing website.">


  <meta name="author" content="Your Name">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="DELPH-IN How-To">
<meta property="og:title" content="DELPH-IN How-To">
<meta property="og:url" content="http://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabLocativePrepositions/">


  <meta property="og:description" content="An amazing website.">











  

  


<link rel="canonical" href="http://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabLocativePrepositions/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Your Name",
      "url": "http://blog.inductorsoftware.com/docsproto/howto/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/docsproto/howto/feed.xml" type="application/atom+xml" rel="alternate" title="DELPH-IN How-To Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/docsproto/howto/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--delphin_page wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/docsproto/howto/"><img src="/docsproto/howto/assets/images/Delph-In.png" alt="DELPH-IN How-To"></a>
        
        <a class="site-title" href="/docsproto/howto/">
          DELPH-IN How-To
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/home/Home">Home</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/howto/DelphinWelcome">How-To</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/erg/ErgTop">ERG</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/tools/ToolsTop">Tools</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/grammars/GrammarsOverview">Grammars</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/matrix/MatrixDocsOverview">Matrix</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/summits/SummitTop">Summits</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/garage/AgreeTop">Garage</a>
            </li><li class="masthead__menu-item">
              <a href="https://blog.inductorsoftware.com/docsproto/missing/AclAnthologyCorpus">Missing</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">DELPH-IN</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/DelphinWelcome/">Welcome</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Developer Tutorial</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoOverview/">Overview</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoMRS/">Minimal Recursion Semantics</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoWellFormedTree/">Well-Formed Trees</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoPredicationContract/">The Predication Contract</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoPythonBasics/">Python Primer and State</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoImplementPredication/">Implementing a Predication</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoMRSToPython/">MRS To Python</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoConjunctions/">Conjunctions</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoScopalArguments/">Scopal Arguments</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoEvents/">Event Variables</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoHandlingEventInformation/">Handling Event Information</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSentenceForce/">Sentence Force</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSimplePropositions/">Simple Propositions</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSimpleQuestions/">Simple Questions</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSimpleCommands/">Simple Commands</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoChoosingWhichFailure/">Reporting the Right Failure</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoReportingAFailure/">A Naive Failure</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoConceptualFailures/">Converting Variables to English</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoRobustFailure/">A More Robust Failure</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoQuantifierErrors/">Quantifier Errors</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoFinishingErrors/">Adding Errors to Every Predication</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoErrorScenarios/">Error Scenarios Summary</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoGenerateMRSAndTrees/">Phrases to MRS and Trees</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoWhichParseAndTree/">Choosing the 'Right' Tree</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoUnknownWords/">Unknown Words and Synonyms</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoPredicationArgumentsAndUsage/">Predication Signatures and Usage</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoDiagnostics/">Diagnostics</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoSimpleTesting/">Testing</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoPythonDecorators/">A. Python Decorators</a></li>
          
            <li><a href="/docsproto/howto/devhowto/devhowtoParsePredication/">B. Parsing Predications</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">(early draft) Developer Predication Tutorial</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/devvocab/devvocabOverview/">Overview</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabPhrasesAndVocab/">Phrases and Vocabulary</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabLoc_nonspAndPlace/">loc_nonsp(e,x,x) and place(x)</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabCustomQueryAnswers/">Custom Query Answers</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabReorderingQuantifierArguments/">Reordering Quantifier Arguments</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabThis_q_dem/">this_q_dem(x,h,h)</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabThing/">thing(x)</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabIn_p_loc/">_in_p_loc(e,x,x)</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabFileDirectoryNames/">fw_seq(...) and quoted(c,i)</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabContextInHelpers/">Errors in Helper Functions</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabGoTo/">_go_v_1 and _to_p_dir</a></li>
          
            <li><a href="/docsproto/howto/devvocab/devvocabLocativePrepositions/" class="active">Locative Prepositions</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Grammarian Tutorial</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/DelphinTutorial/">Overview</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Formalisms/">Formalisms</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Grammars/">Grammars</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Processing/">Processing</a></li>
          
            <li><a href="/docsproto/howto/DelphinTutorial_Distributions/">Distributions</a></li>
          
            <li><a href="/docsproto/howto/HpsgTutorial/">HPSG</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Other Tutorials</span>
        

        
        <ul>
          
            <li><a href="/docsproto/howto/SaarlandAceAgree/">Ace/Agree Tutorial (2013)</a></li>
          
            <li><a href="/docsproto/howto/ErsTutorial/">English Resource Semantics Tutorial (NAACL 2016)</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        <h2 id="verbs-and-locative-prepositions">Verbs and Locative Prepositions</h2>
<p>If the user types the phrase:</p>

<blockquote>
  <p>copy “foo” in “/documents”</p>
</blockquote>

<p>There are 171 different parses that the ERG provides since there is a lot of ambiguity in this phrase.  Here, we’ll focus on the parses that use “copy” as a verb along with “in” as a preposition. Shown below are 4 different patterns (aka <em>phenomena</em>) that appear. They are listed showing the form of the predications for “in” and “copy”, along with their interpretation:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16), _copy_v_1(e2,x3,x8)</code>: copy the ‘foo’ that is in ‘documents’ [where to copy is not specified]</li>
</ol>

<p>This version of “in” has already been implemented <a href="https://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabIn_p_loc">in a previous topic</a> and doesn’t need modification. It takes two <code class="language-plaintext highlighter-rouge">x</code> arguments and restricts them: <code class="language-plaintext highlighter-rouge">x8</code> must be something that is “in” <code class="language-plaintext highlighter-rouge">x16</code>. This is a “locative” form of the “in” preposition that specifies where something is.  So, <code class="language-plaintext highlighter-rouge">in_p_loc</code> indicates where to find <code class="language-plaintext highlighter-rouge">x8</code> (i.e. in <code class="language-plaintext highlighter-rouge">x16</code>), and <code class="language-plaintext highlighter-rouge">copy_v_1</code> simply needs to copy <code class="language-plaintext highlighter-rouge">x8</code>…somewhere.  <em>Where</em> is not specified.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">_in_p_state(e13,e2,x14), _copy_v_1(e2,x3,x8)</code>: copy ‘foo’, and do the copy from within ‘/documents’ [<em>where</em> to copy and where ‘foo’ <em>is</em> are not specified]</li>
</ol>

<p>This reading has a version of “in” that takes the <code class="language-plaintext highlighter-rouge">e2</code> event for its second arg, and <code class="language-plaintext highlighter-rouge">e2</code> is introduced by <code class="language-plaintext highlighter-rouge">_copy_v_1</code>. As described in <a href="https://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabGoTo">the topic about <code class="language-plaintext highlighter-rouge">go_v_1</code></a>, this means that <code class="language-plaintext highlighter-rouge">in_p_state</code> is providing information to <code class="language-plaintext highlighter-rouge">_copy_v_1</code> about <em>how</em> to go about copying. Unlike directional prepositions described in that topic, <code class="language-plaintext highlighter-rouge">_state</code> in the predication name indicates that the preposition is used in a “stative” sense, which effectively means: specifying where the verb is <em>taking place</em>. So this phrase says that the “copying” should be done “in the location specified by <code class="language-plaintext highlighter-rouge">x4</code>”.  Where to copy <em>to</em> is not specified.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">_copy_v_1(e2,x3,x8,_in_p_loc(e15,x8,x16))</code>: copy ‘foo’ such that it ends up in ‘/documents’</li>
</ol>

<p>This version of <code class="language-plaintext highlighter-rouge">_copy_v_1</code> has a scopal argument which contains the “in” preposition. As discussed in the <a href="https://blog.inductorsoftware.com/docsproto/howto/devhowto/devhowtoScopalArguments">section on scopal arguments</a>, scopal arguments occur when the predication needs to do something special with the branch of the tree it is passed.  In this case, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> is being asked to “make <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16)</code> be true”, meaning: change the world such that <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16)</code>. Since <code class="language-plaintext highlighter-rouge">x8</code> is “foo” and <code class="language-plaintext highlighter-rouge">x16</code> is “/documents”, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> should make “foo” be “in” “/documents”.</p>

<ol>
  <li>(not used in this example) <code class="language-plaintext highlighter-rouge">_preposition_p_dir(e,e1,x), verb_v(e1, ...)</code></li>
</ol>

<p>There is another variation of the predication for “in” that the ERG doesn’t provide for this example, but was shown in <a href="https://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabGoTo">the topic on <code class="language-plaintext highlighter-rouge">go_v_1</code></a>. Look at the two interpretations of “the mouse is running under the table”:</p>

<p>(stative) Just like example 1 above: The mouse staying under the table and running around there:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ┌────── _mouse_n_1(x3)
_the_q(x3,RSTR,BODY)            ┌────── _table_n_1(x9)
                 └─ _the_q(x9,RSTR,BODY)    ┌── _under_p_state(e8,e2,x9)
                                     └─ and(0,1)
                                              └ _run_v_1(e2,x3)
</code></pre></div></div>

<p>(directional) Just like <a href="https://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabGoTo"><code class="language-plaintext highlighter-rouge">to_p_dir</code> in the topic on <code class="language-plaintext highlighter-rouge">go_v_1</code></a>: The mouse moving from some other spot in the room on a path that takes it under the table:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ┌────── _table_n_1(x9)
_the_q(x9,RSTR,BODY)            ┌────── _mouse_n_1(x3)
                 └─ _the_q(x3,RSTR,BODY)    ┌── _under_p_dir(e8,e2,x9)
                                     └─ and(0,1)
                                              └ _run_v_1(e2,x3)
</code></pre></div></div>

<p>So, we’ve seen 4 ways a locative preposition can be used with a verb that takes a direction:</p>

<ol>
  <li>(locative) <code class="language-plaintext highlighter-rouge">preposition_p_loc(e,x1,x), verb_v(..., x1)</code>: The verb should do what it does with whatever the preposition put in <code class="language-plaintext highlighter-rouge">x1</code></li>
  <li>(stative) <code class="language-plaintext highlighter-rouge">_preposition_p_state(e,e1,x), verb_v(e1, ...)</code>: The actor or verb is happening at that place</li>
  <li>(scopal) <code class="language-plaintext highlighter-rouge">verb_v(..., preposition_p_loc(e,x,x))</code>: The verb should make this preposition true via what it does</li>
  <li>(directional) <code class="language-plaintext highlighter-rouge">_preposition_p_dir(e,e1,x), verb_v(e1, ...)</code>: The actor or verb are happening in that direction</li>
</ol>

<p>We already have the version of “in” for #1 <a href="https://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabIn_p_loc">implemented</a>, so let’s start there.</p>

<h3 id="1-_in_p_loce15x8x16-_copy_v_1e2x3x8-copy-the-foo-that-is-in-documents">1. <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16), _copy_v_1(e2,x3,x8)</code>: copy the ‘foo’ that is in ‘documents’</h3>
<p>Here is the version of <code class="language-plaintext highlighter-rouge">_in_p_loc</code> that we implemented in a <a href="https://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabIn_p_loc">previous section</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_in_p_loc"])
def in_p_loc(state, e_introduced_binding, x_actor_binding, x_location_binding):
    if x_actor_binding.value is not None:
        if x_location_binding.value is not None:
            # x_actor is "in" x_location if x_location contains it
            for item in x_location_binding.value.contained_items(x_location_binding.variable):
                if x_actor_binding.value == item:
                    # Variables are already set,
                    # no need to set them again, just return the state
                    yield state

        else:
            # Need to find all the things that x_actor is "in"
            if hasattr(x_actor_binding.value, "containers"):
                for item in x_actor_binding.value.containers(x_actor_binding.variable):
                    yield state.set_x(x_location_binding.variable.name, item)

    else:
        # Actor is unbound, this means "What is in X?" type of question
        # Whatever x_location "contains" is "in" it
        if hasattr(x_location_binding.value, "contained_items"):
            for location in x_location_binding.value.contained_items(x_location_binding.variable):
                yield state.set_x(x_actor_binding.variable.name, location)

    report_error(["thingHasNoLocation", x_actor_binding.variable.name, x_location_binding.variable.name])
</code></pre></div></div>

<p>To make this work:</p>

<blockquote>
  <p>copy “file1.txt” in “/documents”</p>
</blockquote>

<p>… we only need to implement <code class="language-plaintext highlighter-rouge">_copy_v_1(e,x,x)</code>.  It will work very much <a href="https://blog.inductorsoftware.com/docsproto/howto/devhowto/devhowtoSimpleCommands">like <code class="language-plaintext highlighter-rouge">_delete_v_1</code></a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># "copy" where the user did not say where to copy to, assume current directory
@Predication(vocabulary, names=["_copy_v_1"])
def copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding):
    # We only know how to copy things from the
    # computer's perspective
    if x_actor_binding.value.name == "Computer":
        # Only allow copying files and folders
        if isinstance(x_what_binding.value, (File, Folder)):
            yield state.apply_operations([CopyOperation(None, x_what_binding, None)])

        else:
            report_error(["cantDo", "copy", x_what_binding.variable.name])

    else:
        report_error(["dontKnowActor", x_actor_binding.variable.name])
        
        
class CopyOperation(object):
    def __init__(self, binding_from_copy, binding_to_copy):
        self.binding_from_copy = binding_from_copy
        self.binding_to_copy = binding_to_copy

    def apply_to(self, state):
        if isinstance(state, FileSystemState):
            state.file_system.copy_item(self.binding_from_copy, self.binding_to_copy)
            
            
class FileSystemMock(FileSystem):

    ...
    
    def copy_item(self, from_binding, to_binding):
        if self.exists(from_binding.value.name, is_file=isinstance(from_binding.value, File)):
            if to_binding is None:
                to_binding = VariableBinding(None, self.current_directory())

            if self.exists(to_binding.value.name, is_file=isinstance(to_binding.value, File)):
                item_name = pathlib.PurePath(from_binding.value.name).parts[-1]
                if isinstance(to_binding.value, Folder):
                    # "to" is a folder, use it as the new base for the file name
                    new_item_path = pathlib.PurePath(to_binding.value.name, item_name)

                else:
                    # "to" includes a file name, use the entire name as the name of the target
                    new_item_path = to_binding.value.name

                new_item = copy.deepcopy(self.item_from_path(from_binding.value.name, is_file=isinstance(from_binding.value, File)))
                new_item.name = new_item_path
                self.items[str(new_item_path)] = new_item

            else:
                raise MessageException("notFound", [to_binding.variable.name])

        else:
            raise MessageException("notFound", [from_binding.variable.name])
</code></pre></div></div>

<p>Now we can copy a file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>? what is in this folder?
File(name=/Desktop/the yearly budget.txt, size=10000000)
File(name=/Desktop/blue, size=1000)

? copy "file1.txt" in "/documents"
Done!

? what is in this folder?
File(name=/Desktop/the yearly budget.txt, size=10000000)
File(name=/Desktop/blue, size=1000)
File(name=/Desktop/file1.txt, size=1000)
</code></pre></div></div>

<p>In this case, “copy ‘file1.txt’ in ‘/documents’” is interpreted as “copy the file ‘/documents/file1.txt’ to my current directory” since “in” is interpreted as applying to where the file is and where to copy <em>to</em> isn’t specified.</p>

<h3 id="2-_in_p_statee13e2x14-_copy_v_1e2x3x8-copy-foo-and-do-the-copy-from-within-documents">2. <code class="language-plaintext highlighter-rouge">_in_p_state(e13,e2,x14), _copy_v_1(e2,x3,x8)</code>: copy ‘foo’, and do the copy from within ‘/documents’</h3>

<p>Next up we’ll tackle the stative version of “in”. Recall that “stative” means where the verb is “happening” and so it tells <code class="language-plaintext highlighter-rouge">_copy_v_1</code> where to do the copying <em>from</em>.</p>

<p>This will work exactly the same as the previous example if there is a relative file name. That is because “doing the copy from within ‘documents’” makes the current directory “/documents” and in the previous example we are interpreting as the file itself being “in” documents. Both approaches resolve to the same file. However, an absolute file name should work here (since current directory is not used when calculating an absolute file name) but should <em>not</em> work in the above example (since the absolute path won’t be “in” that directory).</p>

<p>Here’s the code for stative “in” and a version of “copy” that uses it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_in_p_state"])
def in_p_state(state, e_introduced_binding, e_target_binding, x_location_binding):
    preposition_info = {
        "EndLocation": x_location_binding
    }

    yield state.add_to_e(e_target_binding.variable.name, "StativePreposition", {"Value": preposition_info, "Originator": execution_context().current_predication_index()})


# "copy" where the user specifies where to copy "from". Assume "to" is current directory since it isn't specified
# This is really only different from the locative "_in_p_loc(e15,x8,x16), _copy_v_1(e2,x3,x8)" version if:
# a) The from directory doesn't exist
# b) The thing to copy has a relative path because our "current directory" for the file will be different
@Predication(vocabulary, names=["_copy_v_1"], handles=[("StativePreposition", EventOption.required)])
def stative_copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding):
    x_copy_from_location_binding = e_introduced_binding.value["StativePreposition"]["Value"]["EndLocation"]

    # We only know how to copy things from the
    # computer's perspective
    if x_actor_binding.value.name == "Computer":
        # We only know how to copy something "from" a folder
        if isinstance(x_copy_from_location_binding.value, Folder):
            # Only allow copying files and folders
            if isinstance(x_what_binding.value, (File, Folder)):
                yield state.apply_operations([CopyOperation(x_copy_from_location_binding, x_what_binding, None)])

            else:
                report_error(["cantDo", "copy", x_what_binding.variable.name])

        else:
            report_error(["cantDo", "copy from", x_what_binding.variable.name])

    else:
        report_error(["dontKnowActor", x_actor_binding.variable.name])
</code></pre></div></div>
<p>We’re using the same pattern in <code class="language-plaintext highlighter-rouge">_in_p_state</code> that we used for <code class="language-plaintext highlighter-rouge">_in_p_dir</code> in a <a href="https://blog.inductorsoftware.com/docsproto/howto/devvocab/devvocabGoTo">previous topic</a>: the preposition is just adding its information to the event it is passed, and the verb that introduced that event consumes the information to do its job.</p>

<p><code class="language-plaintext highlighter-rouge">FileSystemMock.copy_item()</code> only changed to use a “copy from” directory to set the base of a relative file name:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class FileSystemMock(FileSystem):
    
    ...
    
    def copy_item(self, from_directory_binding, from_binding, to_binding):
        if from_directory_binding is not None:
            # PurePath will only attach the from_directory_binding.value.name to the front if
            # if from_binding.value is relative, otherwise it is ignored
            from_path = str(pathlib.PurePath(from_directory_binding.value.name, from_binding.value.name))
        else:
            from_path = from_binding.value.name
</code></pre></div></div>

<p>With that in place, we can try two different phrases.  One that will work with the locative “in” we implemented first, and one that will only work with the stative “in”. Since the system will stop once an MRS succeeds, and since the parse for the locative “in” gets executed first, we’ll be able to see if the locative “in” really doesn’t work (and the new one does):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>? copy "file1.txt" in "/documents"
Done!

? /show

...

                           ┌── quoted(\\&gt;documents,i21)
               ┌────── and(0,1)
               │             └ fw_seq(x16,i21)
               │                                                        ┌──── _in_p_loc(e15,x8,x16)
proper_q(x16,RSTR,BODY)                                                 │
                    │                                                   │ ┌── quoted(file1.txt,i13)
                    │                                       ┌────── and(0,1,2)
                    │                 ┌────── pron(x3)      │               │
                    │                 │                     │               └ fw_seq(x8,i13)
                    └─ pronoun_q(x3,RSTR,BODY)              │
                                           └─ proper_q(x8,RSTR,BODY)
                                                                 └─ _copy_v_1(e2,x3,x8)

...

? copy "/Desktop/blue" in "/documents"
Done!

? /show

...

                           ┌── quoted(\\&gt;documents,i21)
               ┌────── and(0,1)
               │             └ fw_seq(x16,i21)
proper_q(x16,RSTR,BODY)                                                 ┌── quoted(\\&gt;Desktop\\&gt;blue,i13)
                    │                                       ┌────── and(0,1)
                    │                 ┌────── pron(x3)      │             └ fw_seq(x8,i13)
                    └─ pronoun_q(x3,RSTR,BODY)              │
                                           └─ proper_q(x8,RSTR,BODY)
                                                                 │      ┌── _in_p_state(e15,e2,x16)
                                                                 └─ and(0,1)
                                                                          └ _copy_v_1(e2,x3,x8)
                                                                          
...
</code></pre></div></div>

<p>Now we have two interpretations of “in” working, let’s move on to the third.</p>

<h3 id="3-_copy_v_1e2x3x8_in_p_loce15x8x16-copy-foo-such-that-it-ends-up-in-documents">3. <code class="language-plaintext highlighter-rouge">_copy_v_1(e2,x3,x8,_in_p_loc(e15,x8,x16))</code>: copy ‘foo’ such that it ends up in ‘/documents’</h3>

<p>This version of <code class="language-plaintext highlighter-rouge">_copy_v_1</code> takes a scopal argument which contains the “in” preposition. As discussed in the <a href="https://blog.inductorsoftware.com/docsproto/howto/devhowto/devhowtoScopalArguments">topic on scopal arguments</a>, scopal arguments occur in places where the predication needs to do something special with the branch of the tree it is passed.  In this case, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> is being asked to “make <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16)</code> be true”, meaning: change the world such that <code class="language-plaintext highlighter-rouge">_in_p_loc(e15,x8,x16)</code>. Since <code class="language-plaintext highlighter-rouge">x8</code> is “foo” and <code class="language-plaintext highlighter-rouge">x16</code> is “/documents”, <code class="language-plaintext highlighter-rouge">_copy_v_1</code> should make “foo” be “in /documents”.</p>

<p>Here are two other examples of verbs taking scopal arguments to illustrate:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>put the vase on the table

            ┌────── _vase_n_1(x8)
_the_q(x8,RSTR,BODY)             ┌────── _table_n_1(x16)
                 └─ _the_q(x16,RSTR,BODY)               ┌────── pron(x3)
                                      └─ pronoun_q(x3,RSTR,BODY)                    ┌─ _on_p_loc(e15,x8,x16)
                                                             └─ _put_v_1(e2,x3,x8,ARG3)
                                                             
paint the tree green

            ┌────── _tree_n_of(x8,i14)
_the_q(x8,RSTR,BODY)               ┌────── pron(x3)
                 └─ pronoun_q(x3,RSTR,BODY)                      ┌─ _green_a_2(e16,x8)
                                        └─ _paint_v_1(e2,x3,x8,ARG3)
</code></pre></div></div>

<p>In all these cases, the verb using a scopal argument because they all share the property that the phrase is taking something in the world and changing it to be something different. This type of scenario needs a scopal argument because a normal predication would attempt to find a “foo” that <em>is</em> in “/documents” … and that is not true yet. The scopal argument doesn’t get evaluated normally (as we’ll see below), so it avoids this problem.</p>

<p>So, verbs with scopal arguments have to do what they do in such a way that their scopal argument becomes true. This can all seem wonderfully abstract if you try to imagine how to write code which “paints x in a way that makes any possible thing true”, but the approach we’re going to take here is much more concrete: Break down each scenario we are focused on for a given verb and implement that.</p>

<p>For example, for “copy ‘foo’ in ‘/documents’”, the scopal argument is a locative preposition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                          ┌── quoted(foo,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _in_p_loc(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)
</code></pre></div></div>

<p>So, we can implement a version of <code class="language-plaintext highlighter-rouge">_copy_v_1</code> that knows how to deal with locative prepositions. If we do it carefully, it will work with all kind of locative prepositions.</p>

<p>Here’s how: Note that the following examples all have the same structure even though they use different locative prepositions, only the preposition is different:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; copy "foo" into "/documents"

                          ┌── quoted(foo,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _into_p(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)


&gt; copy "foo" above "/documents"

                          ┌── quoted(foo,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _above_p(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)
</code></pre></div></div>

<p>We need a mechanism that converts scopal predications into a generic form so all of the examples above can be handled in the same way. This form should allow <code class="language-plaintext highlighter-rouge">_copy_v_1</code> to avoid special casing every single locative preposition.</p>

<p>To do this, we can’t just <code class="language-plaintext highlighter-rouge">call()</code> the scopal argument <code class="language-plaintext highlighter-rouge">_in_p_loc(e17,x8,x18)</code> (as we do for <a href="https://blog.inductorsoftware.com/docsproto/howto/devhowto/devhowtoScopalArguments">quantifiers</a>) – it will fail. “foo” is not yet <em>in</em> “/documents”. Even if it did work, it wouldn’t be in a general form.</p>

<p>Let’s call the form we want: <em>“normalization”</em>. “Normalizing” a predication puts it into a more general or canonical form that reduces whole classes of similar predications (like locative prepositions) into a single form the code can handle once. Here are a couple of examples to clarify:</p>

<ul>
  <li>Normalizing a locative preposition would put it in into a form that contains the thing being located and the place it is being located to. Note that this is <em>not</em> necessarily just the two arguments of a locative preposition, as is. <code class="language-plaintext highlighter-rouge">_above_p(e17,x8,x18)</code>, for example, would need to record the place “above” <code class="language-plaintext highlighter-rouge">x18</code> instead of <code class="language-plaintext highlighter-rouge">x18</code> itself.</li>
  <li>Normalizing an adjective like <code class="language-plaintext highlighter-rouge">_green_a_2(e16,x8)</code> might be as simple as recording the adjective and the thing it is applied to, but it won’t always come from predications that are of the form <code class="language-plaintext highlighter-rouge">adjective(e,x)</code>. “paint the tree lit” (for a Christmas tree, perhaps) generates the “adjective” <code class="language-plaintext highlighter-rouge">_light_v_cause(e16,i17,x8)</code> which is a form of verb being <em>used</em> as an adjective.</li>
</ul>

<p>So, we’ll need to implement another version of each predication that knows how to normalize itself. We’ll ask it to put this normalized form into its own introduced event (since it is just information about itself) so that predications like <code class="language-plaintext highlighter-rouge">_copy_v_1</code> can inspect it and decide what to do. And, just like we use the <code class="language-plaintext highlighter-rouge">_comm</code> postfix on predications that implement commands (as opposed to questions), we’ll invent a new postfix called <code class="language-plaintext highlighter-rouge">_norm</code> to indicate that this version of the predication should only be used when it is asked to normalize.  Like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_in_p_loc"])
def in_p_loc_norm(state, e_introduced_binding, x_actor_binding, x_location_binding):
    preposition_info = {
        "EndLocation": x_location_binding
    }
    yield state.add_to_e(e_introduced_binding.variable.name, "LocativePreposition", {"Value": preposition_info, "Originator": execution_context().current_predication_index()})
</code></pre></div></div>

<p>In this example we’ve decided the normalized form of a locative preposition in an event should have the key <code class="language-plaintext highlighter-rouge">LocativePreposition</code> and this JSON value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "LeftSide": x_actor_binding,
    "EndLocation": x_location_binding
}
</code></pre></div></div>

<p>… which indicates the “left side” of the locative preposition (i.e. the first, or left argument) and the place where that thing should end up.  Note that this normalized form allows the inspector to ignore what the preposition actually <em>is</em> and just deal with “the place the left side should end up”, thus allowing the copy code to be generalized.</p>

<p>Next, we need a way for <code class="language-plaintext highlighter-rouge">copy_v_1</code> to normalize its scopal argument. We can add a <code class="language-plaintext highlighter-rouge">normalize</code> argument to <code class="language-plaintext highlighter-rouge">ExecutionContext._call_predication()</code> that simply asks for predications of type “norm” when it is set. That, along with allowing “norm” as a kind of predication in the <code class="language-plaintext highlighter-rouge">Predication</code> decorator, is all that is needed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ExecutionContext(object):
    
    ...
    
    def _call_predication(self, state, predication, normalize=False):
    
    ...
    
            for module_function in self.vocabulary.predications(predication.name,
                                                            predication.arg_types,
                                                            self._phrase_type if normalize is False else "norm"):
    
    ...
</code></pre></div></div>

<p>The next problem is that the scopal argument for <code class="language-plaintext highlighter-rouge">copy_v_1</code> could be a whole tree. For example:</p>

<blockquote>
  <p>copy “blue” in the folder under “/documents”</p>
</blockquote>

<p>… generates a more complicated scopal argument:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                                                    ┌── quoted(/documents,i29)
            ┌────── _blue_a_1(x8,i14)                   ┌────── and(0,1)
udef_q(x8,RSTR,BODY)             ┌────── _folder_n_of(x1│,i22)        └ fw_seq(x24,i29)
                 └─ _the_q(x17,RSTR,BODY)               │
                                      └─ proper_q(x24,RSTR,BODY)
                                                             │                 ┌────── pron(x3)                    ┌── _under_p_state(e23,e16,x24)
                                                             └─ pronoun_q(x3,RSTR,BODY)                     ┌─ and(0,1)
                                                                                    └─ _copy_v_1(e2,x3,x8,ARG3)      └ _in_p_loc(e16,x8,x17)
</code></pre></div></div>

<p>So we need a way to somehow figure out which of the predications in the scopal argument introduce the event that holds the “LocativePreposition” value.  Because <code class="language-plaintext highlighter-rouge">_copy_v_1</code> has an argument (<code class="language-plaintext highlighter-rouge">x8</code>) which indicates what it should copy, we can assume any predications in the scopal arg that modify <code class="language-plaintext highlighter-rouge">x8</code> are the ones saying where <code class="language-plaintext highlighter-rouge">x8</code> should go.  We can write a helper that returns those events:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Determine which events modify this individual
def scopal_events_modifying_individual(x_individual, h_scopal):
    events = []
    for predication in find_predications_using_variable_ARG1(h_scopal, x_individual):
        if predication.arg_types[0] == "e":
            events.append(predication.args[0])

    return events
</code></pre></div></div>

<p>And now we are finally ready to write the <code class="language-plaintext highlighter-rouge">_copy_v_1</code> verb itself! Be forewarned that there is a lot of “mechanism” in there to fish the right things out of the right places. We’ll fix that next. But first, let’s see the raw code and understand what it does:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Predication(vocabulary, names=["_copy_v_1"])
def locative_copy_v_1_comm(state, e_introduced_binding, x_actor_binding, x_what_binding, h_where):

    # We only know how to copy things from the
    # computer's perspective
    if x_actor_binding.value.name == "Computer":

        # Only allow copying files and folders
        if isinstance(x_what_binding.value, (File, Folder)):
        
            # Determine which events in the scopal argument will hold
            # the LocativePreposition
            where_events = scopal_events_modifying_individual(x_what_binding.variable.name, h_where)
            found_locative_preposition = False
            if len(where_events) &gt; 0:

                # Normalize the tree, which could return multiple solutions like any call()
                for solution in call(state, h_where, normalize=True):
                    
                    # Get the value for each event and see if it holds a 
                    # LocativePreposition
                    for where_event in where_events:
                        e_where_binding = solution.get_binding(where_event)
                        if "LocativePreposition" in e_where_binding.value:
                            
                            # found the information in the event, copy "in" that location
                            found_locative_preposition = True
                            
                            # Only allow copying into folders
                            to_location_binding = e_where_binding.value["LocativePreposition"]["Value"]["EndLocation"]
                            if isinstance(to_location_binding.value, Folder):
                                yield state.apply_operations([CopyOperation(None, x_what_binding, to_location_binding)])

                            else:
                                report_error(["cantDo", "copy", to_location_binding.variable.name])

            if not found_locative_preposition:
                # Fail since we don't know what kind of scopal argument this is
                report_error(["formNotUnderstood", "missing", "LocativePreposition"])

        else:
            report_error(["cantDo", "copy", x_what_binding.variable.name])

    else:
        report_error(["dontKnowActor", x_actor_binding.variable.name])
</code></pre></div></div>

<p>Before we simplify the code, let’s try out some scenarios to make sure it works.  Remember that we have two other interpretations of “copy ‘file1.txt’ in ‘/documents’” that are implemented already. In fact, those two interpretations are returned first by the ERG. So, any phrase that succeeds with one of those won’t exercise this new code.  The phrase “copy ‘blue’ in ‘/documents’” will only work using the latest <code class="language-plaintext highlighter-rouge">copy_v_1</code>, so we’ll use that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>? what is in '/documents'?
File(name=/documents/file1.txt, size=1000)


? what is in this folder?
File(name=/Desktop/the yearly budget.txt, size=10000000)
File(name=/Desktop/blue, size=1000)


? copy 'blue' in '/documents'
Done!

? /show

...

                          ┌── quoted(blue,i14)
              ┌────── and(0,1)
              │             └ fw_seq(x8,i14)
proper_q(x8,RSTR,BODY)                           ┌── quoted(/documents,i23)
                   │                 ┌────── and(0,1)
                   │                 │             └ fw_seq(x18,i23)
                   └─ proper_q(x18,RSTR,BODY)
                                          │                 ┌────── pron(x3)
                                          └─ pronoun_q(x3,RSTR,BODY)                     ┌─ _in_p_loc(e17,x8,x18)
                                                                 └─ _copy_v_1(e2,x3,x8,ARG3)

...

? what is in '/documents'?
File(name=/documents/file1.txt, size=1000)
File(name=/documents/blue, size=1000)
</code></pre></div></div>

<p>Just to make sure that the expected parse is, in fact, what worked, <code class="language-plaintext highlighter-rouge">/show</code> was executed so we could see the successful tree used and validate it.</p>

<p>Because this code will be the same for all predications that deal with scopal arguments, we can simplify it by writing some helpers.</p>

<p>Last update: 2023-02-02 by EricZinda [<a href="https://github.com/ericzinda/Perplexity/edit/main/docs/devvocab/devvocabLocativePrepositions.md">edit</a>]</p>

        
      </section>

      <footer class="page__meta">
        
        


        


      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

<!--Scroll the navbar to the current page-->
<script type="text/javascript">
  let el = document.querySelector('.nav__list .active');
  if(el){
    el.scrollIntoView({block: "center", inline: "start"});
  }
</script>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/docsproto/howto/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Your Name. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/docsproto/howto/assets/js/main.min.js"></script>




<script src="/docsproto/howto/assets/js/lunr/lunr.min.js"></script>
<script src="/docsproto/howto/assets/js/lunr/lunr-store.js"></script>
<script src="/docsproto/howto/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
